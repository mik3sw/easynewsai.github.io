{"version":3,"sources":["../src/lib/BaseSuggestionPlugin.ts","../src/lib/withSuggestion.ts","../src/lib/transforms/deleteFragmentSuggestion.ts","../src/lib/transforms/deleteSuggestion.ts","../src/lib/queries/findSuggestionId.ts","../src/lib/queries/findSuggestionNode.ts","../src/lib/utils/getSuggestionKeys.ts","../src/lib/utils/getSuggestionNodeEntries.ts","../src/lib/utils/getActiveSuggestionDescriptions.ts","../src/lib/utils/getSuggestionId.ts","../src/lib/transforms/getSuggestionProps.ts","../src/lib/transforms/setSuggestionNodes.ts","../src/lib/transforms/insertFragmentSuggestion.ts","../src/lib/transforms/insertTextSuggestion.ts","../src/lib/diffToSuggestions.ts","../src/lib/transforms/acceptSuggestion.ts","../src/lib/transforms/addSuggestionMark.ts","../src/lib/transforms/rejectSuggestion.ts"],"sourcesContent":["import {\n  type PluginConfig,\n  type WithPartial,\n  createTSlatePlugin,\n  nanoid,\n} from '@udecode/plate-common';\n\nimport type { SuggestionUser, TSuggestion } from './types';\n\nimport { withSuggestion } from './withSuggestion';\n\nexport const SUGGESTION_KEYS = {\n  id: 'suggestionId',\n} as const;\n\nexport type SuggestionConfig = PluginConfig<\n  'suggestion',\n  {\n    activeSuggestionId: string | null;\n    currentUserId: string | null;\n    isSuggesting: boolean;\n    suggestions: Record<string, TSuggestion>;\n    users: Record<string, SuggestionUser>;\n    onSuggestionAdd: ((value: Partial<TSuggestion>) => void) | null;\n    onSuggestionDelete: ((id: string) => void) | null;\n    onSuggestionUpdate:\n      | ((\n          value: Partial<Omit<TSuggestion, 'id'>> & Pick<TSuggestion, 'id'>\n        ) => void)\n      | null;\n  } & SuggestionSelectors,\n  {\n    suggestion: SuggestionPluginApi;\n  }\n>;\n\nexport type SuggestionSelectors = {\n  currentSuggestionUser?: () => SuggestionUser | null;\n  suggestionById?: (id: string | null) => TSuggestion | null;\n  suggestionUserById?: (id: string | null) => SuggestionUser | null;\n};\n\nexport type SuggestionPluginApi = {\n  addSuggestion: (\n    value: WithPartial<TSuggestion, 'createdAt' | 'id' | 'userId'>\n  ) => void;\n  removeSuggestion: (id: string | null) => void;\n  updateSuggestion: (id: string | null, value: Partial<TSuggestion>) => void;\n};\n\nexport const BaseSuggestionPlugin = createTSlatePlugin<SuggestionConfig>({\n  key: 'suggestion',\n  extendEditor: withSuggestion,\n  node: { isLeaf: true },\n  options: {\n    activeSuggestionId: null,\n    currentUserId: null,\n    isSuggesting: false,\n    suggestions: {},\n    users: {},\n    onSuggestionAdd: null,\n    onSuggestionDelete: null,\n    onSuggestionUpdate: null,\n  },\n})\n  .extendOptions(({ getOptions }) => ({\n    currentSuggestionUser: (): SuggestionUser | null => {\n      const { currentUserId, users } = getOptions();\n\n      if (!currentUserId) return null;\n\n      return users[currentUserId];\n    },\n    suggestionById: (id: string | null): TSuggestion | null => {\n      if (!id) return null;\n\n      return getOptions().suggestions[id];\n    },\n    suggestionUserById: (id: string | null): SuggestionUser | null => {\n      if (!id) return null;\n\n      return getOptions().users[id];\n    },\n  }))\n  .extendApi<Partial<SuggestionPluginApi>>(({ getOptions, setOptions }) => ({\n    addSuggestion: (\n      value: WithPartial<TSuggestion, 'createdAt' | 'id' | 'userId'>\n    ) => {\n      const { currentUserId } = getOptions();\n\n      if (!currentUserId) return;\n\n      const id = value.id ?? nanoid();\n      const newSuggestion: TSuggestion = {\n        id,\n        createdAt: Date.now(),\n        userId: currentUserId,\n        ...value,\n      };\n\n      setOptions((draft) => {\n        draft.suggestions[id] = newSuggestion;\n      });\n    },\n    removeSuggestion: (id: string | null) => {\n      if (!id) return;\n\n      setOptions((draft) => {\n        delete draft.suggestions[id];\n      });\n    },\n    updateSuggestion: (id: string | null, value: Partial<TSuggestion>) => {\n      if (!id) return;\n\n      setOptions((draft) => {\n        draft.suggestions[id] = { ...draft.suggestions[id], ...value };\n      });\n    },\n  }));\n","import {\n  type ExtendEditor,\n  getNode,\n  getPointAfter,\n  getPointBefore,\n  removeNodes,\n  setNodes,\n  unsetNodes,\n} from '@udecode/plate-common';\n\nimport type { TSuggestionText } from './types';\n\nimport {\n  type SuggestionConfig,\n  BaseSuggestionPlugin,\n  SUGGESTION_KEYS,\n} from './BaseSuggestionPlugin';\nimport { deleteFragmentSuggestion } from './transforms/deleteFragmentSuggestion';\nimport { deleteSuggestion } from './transforms/deleteSuggestion';\nimport { insertFragmentSuggestion } from './transforms/insertFragmentSuggestion';\nimport { insertTextSuggestion } from './transforms/insertTextSuggestion';\nimport { getSuggestionId, getSuggestionKeys } from './utils/index';\n\nexport const withSuggestion: ExtendEditor<SuggestionConfig> = ({\n  editor,\n  getOptions,\n}) => {\n  const {\n    deleteBackward,\n    deleteForward,\n    deleteFragment,\n    insertBreak,\n    insertFragment,\n    insertText,\n    normalizeNode,\n  } = editor;\n\n  editor.insertBreak = () => {\n    if (getOptions().isSuggesting) {\n      // TODO: split node\n      insertTextSuggestion(editor, '\\n');\n\n      return;\n    }\n\n    insertBreak();\n  };\n\n  editor.insertText = (text) => {\n    if (getOptions().isSuggesting) {\n      insertTextSuggestion(editor, text);\n\n      return;\n    }\n\n    insertText(text);\n  };\n\n  editor.insertFragment = (fragment) => {\n    if (getOptions().isSuggesting) {\n      insertFragmentSuggestion(editor, fragment, { insertFragment });\n\n      return;\n    }\n\n    insertFragment(fragment);\n  };\n\n  editor.deleteFragment = (direction) => {\n    if (getOptions().isSuggesting) {\n      deleteFragmentSuggestion(editor, { reverse: true });\n\n      return;\n    }\n\n    deleteFragment(direction);\n  };\n\n  editor.deleteBackward = (unit) => {\n    if (getOptions().isSuggesting) {\n      const selection = editor.selection!;\n      const pointTarget = getPointBefore(editor, selection, {\n        unit,\n      });\n\n      if (!pointTarget) return;\n\n      deleteSuggestion(\n        editor,\n        { anchor: selection.anchor, focus: pointTarget },\n        {\n          reverse: true,\n        }\n      );\n\n      return;\n    }\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteForward = (unit) => {\n    if (getOptions().isSuggesting) {\n      const selection = editor.selection!;\n\n      const pointTarget = getPointAfter(editor, selection, { unit });\n\n      if (!pointTarget) return;\n\n      deleteSuggestion(editor, {\n        anchor: selection.anchor,\n        focus: pointTarget,\n      });\n\n      return;\n    }\n\n    deleteForward(unit);\n  };\n\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n\n    if (node[BaseSuggestionPlugin.key]) {\n      const pointBefore = getPointBefore(editor, path);\n\n      // Merge with previous suggestion\n      if (pointBefore) {\n        const nodeBefore = getNode(editor, pointBefore.path);\n\n        if (\n          (nodeBefore as any)?.[BaseSuggestionPlugin.key] &&\n          (nodeBefore as any)[SUGGESTION_KEYS.id] !== node[SUGGESTION_KEYS.id]\n        ) {\n          setNodes<TSuggestionText>(\n            editor,\n            { [SUGGESTION_KEYS.id]: (nodeBefore as any)[SUGGESTION_KEYS.id] },\n            { at: path }\n          );\n\n          return;\n        }\n      }\n      // Unset suggestion when there is no suggestion id\n      if (!getSuggestionId(node)) {\n        const keys = getSuggestionKeys(node);\n        unsetNodes(\n          editor,\n          [BaseSuggestionPlugin.key, 'suggestionDeletion', ...keys],\n          {\n            at: path,\n          }\n        );\n\n        return;\n      }\n      // Unset suggestion when there is no suggestion user id\n      if (getSuggestionKeys(node).length === 0) {\n        if (node.suggestionDeletion) {\n          // Unset deletions\n          unsetNodes(editor, [BaseSuggestionPlugin.key, SUGGESTION_KEYS.id], {\n            at: path,\n          });\n        } else {\n          // Remove additions\n          removeNodes(editor, { at: path });\n        }\n\n        return;\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n\n// editor.apply = (op) => {\n//   if (getOptions().isSuggesting) {\n//     if (op.type === 'insert_text') {\n//       const { text, path, offset } = op;\n//\n//       const id = findSuggestionId(editor, { path, offset }) ?? nanoid();\n//\n//       // const node = getNode(editor, path) as TSuggestionText;\n//       // if (node && node.suggestionId !== id) {\n//       insertNodes<TSuggestionText>(\n//         editor,\n//         { text, [SuggestionPlugin.key]: true, [SUGGESTION_KEYS.id]: id },\n//         {\n//           at: {\n//             path,\n//             offset,\n//           },\n//           select: true,\n//         }\n//       );\n//       return;\n//       // }\n//     }\n//     if (op.type === 'insert_node') {\n//       const { node, path } = op;\n//\n//       const suggestionNode = node as TSuggestionText;\n//\n//       if (\n//         suggestionNode[SuggestionPlugin.key] &&\n//         suggestionNode[SUGGESTION_KEYS.id] &&\n//         !suggestionNode.suggestionDeletion\n//       ) {\n//         apply(op);\n//         return;\n//       }\n//\n//       if (!suggestionNode[SuggestionPlugin.key]) {\n//         // Add suggestion mark\n//         suggestionNode[SuggestionPlugin.key] = true;\n//       }\n//       if (suggestionNode.suggestionDeletion) {\n//         // Remove suggestion deletion mark\n//         delete suggestionNode.suggestionDeletion;\n//       }\n//\n//       const id = findSuggestionId(editor, path) ?? nanoid();\n//       suggestionNode[SUGGESTION_KEYS.id] = id;\n//\n//       insertNodes(editor, cloneDeep(node) as any, { at: path });\n//       return;\n//     }\n//     if (op.type === 'remove_node') {\n//       const { node } = op;\n//\n//       // additions are safe to remove\n//       if (node[SuggestionPlugin.key]) {\n//         if (!node.suggestionDeletion) {\n//           apply(op);\n//         }\n//         return;\n//       }\n//\n//       const path = findNodePath(editor, node);\n//       if (!path) return;\n//\n//       const id = findSuggestionId(editor, path) ?? nanoid();\n//\n//       setSuggestionNodes(editor, {\n//         at: path,\n//         suggestionDeletion: true,\n//         suggestionId: id,\n//       });\n//       // ðŸ’¡ set instead of remove -> selection gets wrong\n//       return;\n//     }\n//     if (op.type === 'remove_text') {\n//       const { path, offset, text } = op;\n//\n//       const from = { path, offset };\n//\n//       const node = getNode<TText>(editor, path);\n//       if (!node) return;\n//\n//       // additions are safe to remove\n//       if (node[SuggestionPlugin.key] && !node.suggestionDeletion) {\n//         apply(op);\n//         return;\n//       }\n//\n//       const to = {\n//         path,\n//         offset: offset + text.length,\n//       };\n//       const id =\n//         findSuggestionId(editor, {\n//           anchor: from,\n//           focus: to,\n//         }) ?? nanoid();\n//\n//       setSuggestionNodes(editor, {\n//         at: {\n//           anchor: from,\n//           focus: to,\n//         },\n//         suggestionDeletion: true,\n//         suggestionId: id,\n//       });\n//       // ðŸ’¡ set instead of remove -> selection gets wrong\n//       return;\n//     }\n//     if (op.type === 'move_node') {\n//       const node = getNode(editor, op.path);\n//       if (node && isBlock(editor, node) && !node[SuggestionPlugin.key]) {\n//         // TODO: ?\n//         return;\n//       }\n//     }\n//     if (op.type === 'merge_node') {\n//       const node = getNode(editor, op.path);\n//       if (node && isBlock(editor, node)) {\n//         // if (node && isBlock(editor, node) && !node[SuggestionPlugin.key]) {\n//         // TODO: delete block suggestion\n//         return;\n//       }\n//     }\n//     if (op.type === 'split_node') {\n//       const node = getNode(editor, op.path);\n//       // allow splitting suggestion blocks\n//       if (node && isBlock(editor, node) && !node[SuggestionPlugin.key]) {\n//         // TODO: insert block suggestion\n//         return;\n//       }\n//     }\n//     if (op.type === 'set_selection') {\n//       if (editor.preventSelection) {\n//         return;\n//       }\n//     }\n//   }\n//\n//   apply(op);\n// };\n","import {\n  type SlateEditor,\n  collapseSelection,\n  getEdgePoints,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport { deleteSuggestion } from './deleteSuggestion';\n\nexport const deleteFragmentSuggestion = (\n  editor: SlateEditor,\n  { reverse }: { reverse?: boolean } = {}\n) => {\n  withoutNormalizing(editor, () => {\n    const selection = editor.selection!;\n\n    const [start, end] = getEdgePoints(editor, selection);\n\n    if (reverse) {\n      collapseSelection(editor, { edge: 'end' });\n      deleteSuggestion(\n        editor,\n        { anchor: end, focus: start },\n        { reverse: true }\n      );\n    } else {\n      collapseSelection(editor, { edge: 'start' });\n      deleteSuggestion(editor, { anchor: start, focus: end });\n    }\n  });\n};\n","import {\n  type SlateEditor,\n  type TElement,\n  createPointRef,\n  deleteText,\n  findNode,\n  getEditorString,\n  getPointAfter,\n  getPointBefore,\n  isBlock,\n  isElementEmpty,\n  isRangeAcrossBlocks,\n  isStartPoint,\n  moveSelection,\n  nanoid,\n  removeNodes,\n  unhangCharacterRange,\n  withoutNormalizing,\n} from '@udecode/plate-common';\nimport { type Range, Point } from 'slate';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\nimport { findSuggestionId } from '../queries/findSuggestionId';\nimport { findSuggestionNode } from '../queries/index';\nimport { getSuggestionCurrentUserKey } from './getSuggestionProps';\nimport { setSuggestionNodes } from './setSuggestionNodes';\n\n/**\n * Suggest deletion one character at a time until target point is reached.\n * Suggest additions are safely deleted.\n */\nexport const deleteSuggestion = (\n  editor: SlateEditor,\n  at: Range,\n  {\n    reverse,\n  }: {\n    reverse?: boolean;\n  } = {}\n) => {\n  withoutNormalizing(editor, () => {\n    const { anchor: from, focus: to } = at;\n\n    const suggestionId = findSuggestionId(editor, from) ?? nanoid();\n\n    const toRef = createPointRef(editor, to);\n\n    let pointCurrent: Point | undefined;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      pointCurrent = editor.selection?.anchor;\n\n      if (!pointCurrent) break;\n\n      const pointTarget = toRef.current;\n\n      if (!pointTarget) break;\n      // don't delete across blocks\n      if (\n        !isRangeAcrossBlocks(editor, {\n          at: { anchor: pointCurrent, focus: pointTarget },\n        })\n      ) {\n        // always 0 when across blocks\n        const str = getEditorString(\n          editor,\n          reverse\n            ? {\n                anchor: pointTarget,\n                focus: pointCurrent,\n              }\n            : {\n                anchor: pointCurrent,\n                focus: pointTarget,\n              }\n        );\n\n        if (str.length === 0) break;\n      }\n\n      const getPoint = reverse ? getPointBefore : getPointAfter;\n\n      const pointNext = getPoint(editor, pointCurrent, {\n        unit: 'character',\n      });\n\n      if (!pointNext) break;\n\n      let range = reverse\n        ? {\n            anchor: pointNext,\n            focus: pointCurrent,\n          }\n        : {\n            anchor: pointCurrent,\n            focus: pointNext,\n          };\n      range = unhangCharacterRange(editor, range);\n\n      // if the current point is in block addition suggestion, delete block\n      const entryBlock = findNode<TElement>(editor, {\n        at: pointCurrent,\n        match: (n) =>\n          isBlock(editor, n) &&\n          n[BaseSuggestionPlugin.key] &&\n          !n.suggestionDeletion &&\n          n[getSuggestionCurrentUserKey(editor)],\n      });\n\n      if (\n        entryBlock &&\n        isStartPoint(editor, pointCurrent, entryBlock[1]) &&\n        isElementEmpty(editor, entryBlock[0] as any)\n      ) {\n        removeNodes(editor, {\n          at: entryBlock[1],\n        });\n\n        continue;\n      }\n      // move selection if still the same\n      if (Point.equals(pointCurrent, editor.selection!.anchor)) {\n        moveSelection(editor, {\n          reverse,\n          unit: 'character',\n        });\n      }\n      // skip if the range is across blocks\n      if (\n        isRangeAcrossBlocks(editor, {\n          at: range,\n        })\n      ) {\n        continue;\n      }\n\n      // if the current point is in addition suggestion, delete\n      const entryText = findSuggestionNode(editor, {\n        at: range,\n        match: (n) =>\n          !n.suggestionDeletion && n[getSuggestionCurrentUserKey(editor)],\n      });\n\n      if (entryText) {\n        deleteText(editor, { at: range, unit: 'character' });\n\n        continue;\n      }\n\n      setSuggestionNodes(editor, {\n        at: range,\n        suggestionDeletion: true,\n        suggestionId,\n      });\n    }\n  });\n};\n","import type { Location, Point } from 'slate';\n\nimport {\n  type SlateEditor,\n  getEdgePoints,\n  getPointAfter,\n  getPointBefore,\n} from '@udecode/plate-common';\n\nimport { SUGGESTION_KEYS } from '../BaseSuggestionPlugin';\nimport { findSuggestionNode } from './findSuggestionNode';\n\n/**\n * Find the suggestion id at the cursor point, the point before and after (if\n * offset = 0).\n */\nexport const findSuggestionId = (editor: SlateEditor, at: Location) => {\n  let entry = findSuggestionNode(editor, {\n    at,\n  });\n\n  if (!entry) {\n    let start: Point;\n    let end: Point;\n\n    try {\n      [start, end] = getEdgePoints(editor, at);\n    } catch {\n      return;\n    }\n\n    const nextPoint = getPointAfter(editor, end);\n\n    if (nextPoint) {\n      entry = findSuggestionNode(editor, {\n        at: nextPoint,\n      });\n\n      if (!entry) {\n        const prevPoint = getPointBefore(editor, start);\n\n        if (prevPoint) {\n          entry = findSuggestionNode(editor, {\n            at: prevPoint,\n          });\n        }\n      }\n    }\n  }\n  if (entry) {\n    return entry[0][SUGGESTION_KEYS.id];\n  }\n};\n","import {\n  type FindNodeOptions,\n  type SlateEditor,\n  findNode,\n} from '@udecode/plate-common';\n\nimport type { TSuggestionText } from '../types';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\n\nexport const findSuggestionNode = <E extends SlateEditor>(\n  editor: E,\n  { match, ...options }: FindNodeOptions<E> = {}\n) =>\n  findNode<TSuggestionText>(editor, {\n    match: (n, p) =>\n      n[BaseSuggestionPlugin.key] && (!match || (match as any)(n, p)),\n    ...options,\n  });\n","import { type TNode, isDefined } from '@udecode/plate-common';\n\nimport { BaseSuggestionPlugin } from '../BaseSuggestionPlugin';\n\nexport const getSuggestionKey = (id = '0') =>\n  `${BaseSuggestionPlugin.key}_${id}`;\n\nexport const isSuggestionKey = (key: string) =>\n  key.startsWith(`${BaseSuggestionPlugin.key}_`);\n\nexport const getSuggestionKeys = (node: TNode) => {\n  const keys: string[] = [];\n\n  Object.keys(node).forEach((key) => {\n    if (isSuggestionKey(key)) keys.push(key);\n  });\n\n  return keys;\n};\n\nexport const getSuggestionUserIdByKey = (key?: string | null) =>\n  isDefined(key) ? key.split(`${BaseSuggestionPlugin.key}_`)[1] : null;\n\nexport const getSuggestionUserIds = (node: TNode) => {\n  return getSuggestionKeys(node).map(\n    (key) => getSuggestionUserIdByKey(key) as string\n  );\n};\n\nexport const getSuggestionUserId = (node: TNode) => {\n  return getSuggestionUserIds(node)[0];\n};\n","import {\n  type GetNodeEntriesOptions,\n  type SlateEditor,\n  getNodeEntries,\n} from '@udecode/plate-common';\n\nimport type { TSuggestionText } from '../types';\n\nexport const getSuggestionNodeEntries = <E extends SlateEditor>(\n  editor: E,\n  suggestionId: string,\n  {\n    at = [],\n    match = () => true,\n    ...options\n  }: {\n    match?: (suggestion: TSuggestionText) => boolean;\n  } & GetNodeEntriesOptions<E> = {}\n) =>\n  getNodeEntries<TSuggestionText>(editor, {\n    at,\n    match: (n) =>\n      n.suggestionId === suggestionId && match(n as TSuggestionText),\n    ...options,\n  });\n","import type { SlateEditor } from '@udecode/plate-common';\n\nimport { findSuggestionNode } from '../queries/index';\nimport { getSuggestionKey, getSuggestionUserIds } from './getSuggestionKeys';\nimport { getSuggestionNodeEntries } from './getSuggestionNodeEntries';\n\nexport type TSuggestionCommonDescription = {\n  suggestionId: string;\n  userId: string;\n};\n\n// TODO: Move to ../types\nexport type TSuggestionInsertionDescription = {\n  insertedText: string;\n  type: 'insertion';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionDeletionDescription = {\n  deletedText: string;\n  type: 'deletion';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionReplacementDescription = {\n  deletedText: string;\n  insertedText: string;\n  type: 'replacement';\n} & TSuggestionCommonDescription;\n\nexport type TSuggestionDescription =\n  | TSuggestionDeletionDescription\n  | TSuggestionInsertionDescription\n  | TSuggestionReplacementDescription;\n\n/**\n * Get the suggestion descriptions of the selected node. A node can have\n * multiple suggestions (multiple users). Each description maps to a user\n * suggestion.\n */\nexport const getActiveSuggestionDescriptions = (\n  editor: SlateEditor\n): TSuggestionDescription[] => {\n  const aboveEntry = findSuggestionNode(editor);\n\n  if (!aboveEntry) return [];\n\n  const aboveNode = aboveEntry[0];\n  const suggestionId = aboveNode.suggestionId!;\n\n  const userIds = getSuggestionUserIds(aboveNode);\n\n  return userIds.map((userId) => {\n    const nodes = Array.from(\n      getSuggestionNodeEntries(editor, suggestionId, {\n        match: (n: any) => n[getSuggestionKey(userId)],\n      })\n    ).map(([node]) => node);\n    const insertions = nodes.filter((node) => !node.suggestionDeletion);\n    const deletions = nodes.filter((node) => node.suggestionDeletion);\n    const insertedText = insertions.map((node) => node.text).join('');\n    const deletedText = deletions.map((node) => node.text).join('');\n\n    if (insertions.length > 0 && deletions.length > 0) {\n      return {\n        deletedText,\n        insertedText,\n        suggestionId,\n        type: 'replacement',\n        userId,\n      };\n    }\n    if (deletions.length > 0) {\n      return {\n        deletedText,\n        suggestionId,\n        type: 'deletion',\n        userId,\n      };\n    }\n\n    return {\n      insertedText,\n      suggestionId,\n      type: 'insertion',\n      userId,\n    };\n  });\n};\n","import type { TNode } from '@udecode/plate-common';\n\nimport { SUGGESTION_KEYS } from '../BaseSuggestionPlugin';\n\nexport const getSuggestionId = (node: TNode) => {\n  return node[SUGGESTION_KEYS.id] as string | undefined;\n};\n","import type { SlateEditor } from '@udecode/plate-common';\n\nimport { BaseSuggestionPlugin, SUGGESTION_KEYS } from '../BaseSuggestionPlugin';\nimport { getSuggestionKey } from '../utils/index';\n\nexport const getSuggestionCurrentUserKey = (editor: SlateEditor) => {\n  const { currentUserId } = editor.getOptions(BaseSuggestionPlugin);\n\n  return getSuggestionKey(currentUserId!);\n};\n\nexport const getSuggestionProps = (\n  editor: SlateEditor,\n  id: string,\n  {\n    suggestionDeletion,\n    suggestionUpdate,\n  }: {\n    suggestionDeletion?: boolean;\n    suggestionUpdate?: any;\n  } = {}\n) => {\n  const res = {\n    [BaseSuggestionPlugin.key]: true,\n    [SUGGESTION_KEYS.id]: id,\n    [getSuggestionCurrentUserKey(editor)]: true,\n  };\n\n  if (suggestionDeletion) {\n    res.suggestionDeletion = true;\n  }\n  if (suggestionUpdate) {\n    res.suggestionUpdate = suggestionUpdate;\n  }\n\n  return res;\n};\n","import {\n  type SetNodesOptions,\n  type SlateEditor,\n  type TNodeProps,\n  addRangeMarks,\n  getNodeEntries,\n  isInline,\n  nanoid,\n  setNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport type { TSuggestionText } from '../types';\n\nimport { getSuggestionProps } from './getSuggestionProps';\n\nexport const setSuggestionNodes = (\n  editor: SlateEditor,\n  options?: {\n    suggestionDeletion?: boolean;\n    suggestionId?: string;\n  } & SetNodesOptions\n) => {\n  const { at = editor.selection, suggestionId = nanoid() } = options ?? {};\n\n  // TODO: get all inline nodes to be set\n  const _nodeEntries = getNodeEntries(editor, {\n    match: (n) => isInline(editor, n),\n    ...options,\n  });\n  const nodeEntries = [..._nodeEntries];\n\n  withoutNormalizing(editor, () => {\n    const props: TNodeProps<TSuggestionText> = getSuggestionProps(\n      editor,\n      suggestionId,\n      options\n    );\n\n    addRangeMarks(editor, props, {\n      at,\n    });\n\n    nodeEntries.forEach(([, path]) => {\n      setNodes<TSuggestionText>(editor, props, {\n        at: path,\n        match: (n) => {\n          if (!isInline(editor, n)) return false;\n\n          return true;\n        },\n        ...options,\n      });\n    });\n  });\n};\n","import {\n  type SlateEditor,\n  type TDescendant,\n  applyDeepToNodes,\n  nanoid,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport { BaseSuggestionPlugin, SUGGESTION_KEYS } from '../BaseSuggestionPlugin';\nimport { findSuggestionId } from '../queries/findSuggestionId';\nimport { getSuggestionKeys } from '../utils/index';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\nimport { getSuggestionCurrentUserKey } from './getSuggestionProps';\n\nexport const insertFragmentSuggestion = (\n  editor: SlateEditor,\n  fragment: TDescendant[],\n  {\n    insertFragment = editor.insertFragment,\n  }: {\n    insertFragment?: (fragment: TDescendant[]) => void;\n  } = {}\n) => {\n  withoutNormalizing(editor, () => {\n    deleteFragmentSuggestion(editor);\n\n    const id = findSuggestionId(editor, editor.selection!) ?? nanoid();\n\n    fragment.forEach((node) => {\n      applyDeepToNodes({\n        apply: (n) => {\n          if (!n[BaseSuggestionPlugin.key]) {\n            // Add suggestion mark\n            n[BaseSuggestionPlugin.key] = true;\n          }\n          if (n.suggestionDeletion) {\n            // Remove suggestion deletion mark\n            delete n.suggestionDeletion;\n          }\n\n          n[SUGGESTION_KEYS.id] = id;\n\n          // remove the other user keys\n          const otherUserKeys = getSuggestionKeys(n);\n          otherUserKeys.forEach((key) => {\n            delete n[key];\n          });\n\n          // set current user key\n          n[getSuggestionCurrentUserKey(editor)] = true;\n        },\n        node,\n        source: {},\n      });\n    });\n\n    insertFragment(fragment);\n  });\n};\n","import {\n  type SlateEditor,\n  insertNodes,\n  isSelectionExpanded,\n  nanoid,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport type { TSuggestionText } from '../types';\n\nimport { findSuggestionId } from '../queries/findSuggestionId';\nimport { deleteFragmentSuggestion } from './deleteFragmentSuggestion';\nimport { getSuggestionProps } from './getSuggestionProps';\n\nexport const insertTextSuggestion = (editor: SlateEditor, text: string) => {\n  withoutNormalizing(editor, () => {\n    const id = findSuggestionId(editor, editor.selection!) ?? nanoid();\n\n    if (isSelectionExpanded(editor)) {\n      deleteFragmentSuggestion(editor);\n    }\n\n    insertNodes<TSuggestionText>(\n      editor,\n      {\n        text,\n        ...getSuggestionProps(editor, id),\n      },\n      {\n        at: editor.selection!,\n        select: true,\n      }\n    );\n  });\n};\n","import {\n  type SlateEditor,\n  type TDescendant,\n  type ValueOf,\n  nanoid,\n} from '@udecode/plate-common';\nimport { type ComputeDiffOptions, computeDiff } from '@udecode/plate-diff';\n\nimport { getSuggestionProps } from './transforms';\n\nexport function diffToSuggestions<E extends SlateEditor>(\n  editor: E,\n  doc0: TDescendant[],\n  doc1: TDescendant[],\n  {\n    getDeleteProps = () =>\n      getSuggestionProps(editor, nanoid(), {\n        suggestionDeletion: true,\n      }),\n    getInsertProps = () => getSuggestionProps(editor, nanoid()),\n    getUpdateProps = (_node, _properties, newProperties) =>\n      getSuggestionProps(editor, nanoid(), {\n        suggestionUpdate: newProperties,\n      }),\n    isInline = editor.isInline,\n    ...options\n  }: Partial<ComputeDiffOptions> = {}\n): ValueOf<E> {\n  return computeDiff(doc0, doc1, {\n    getDeleteProps,\n    getInsertProps,\n    getUpdateProps,\n    isInline,\n    ...options,\n  }) as ValueOf<E>;\n}\n","import {\n  type SlateEditor,\n  removeNodes,\n  unsetNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport type { TSuggestionText } from '../types';\n\nimport { BaseSuggestionPlugin, SUGGESTION_KEYS } from '../BaseSuggestionPlugin';\nimport { type TSuggestionDescription, getSuggestionKey } from '../utils/index';\n\nexport const acceptSuggestion = (\n  editor: SlateEditor,\n  description: TSuggestionDescription\n) => {\n  withoutNormalizing(editor as any, () => {\n    const suggestionKey = getSuggestionKey(description.userId);\n\n    unsetNodes(editor as any, [BaseSuggestionPlugin.key, suggestionKey], {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // unset additions\n        return (\n          node[SUGGESTION_KEYS.id] === description.suggestionId &&\n          !node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n    removeNodes(editor as any, {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // remove deletions\n        return (\n          node[SUGGESTION_KEYS.id] === description.suggestionId &&\n          !!node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n  });\n};\n","import { type SlateEditor, nanoid } from '@udecode/plate-common';\n\nimport { BaseSuggestionPlugin, SUGGESTION_KEYS } from '../BaseSuggestionPlugin';\nimport { findSuggestionId } from '../queries/findSuggestionId';\n\nexport const addSuggestionMark = (editor: SlateEditor) => {\n  if (!editor.selection) return;\n\n  const id = findSuggestionId(editor, editor.selection) ?? nanoid();\n\n  if (!editor.marks?.[BaseSuggestionPlugin.key]) {\n    editor.addMark(BaseSuggestionPlugin.key, true);\n  }\n  if (!editor.marks?.[SUGGESTION_KEYS.id]) {\n    editor.addMark(SUGGESTION_KEYS.id, id);\n  }\n};\n","import {\n  type SlateEditor,\n  removeNodes,\n  unsetNodes,\n  withoutNormalizing,\n} from '@udecode/plate-common';\n\nimport type { TSuggestionText } from '../types';\n\nimport { SUGGESTION_KEYS } from '../BaseSuggestionPlugin';\nimport { type TSuggestionDescription, getSuggestionKey } from '../utils/index';\n\nexport const rejectSuggestion = (\n  editor: SlateEditor,\n  description: TSuggestionDescription\n) => {\n  const suggestionKey = getSuggestionKey(description.userId);\n\n  withoutNormalizing(editor as any, () => {\n    unsetNodes(editor as any, [suggestionKey], {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // unset deletions\n        return (\n          node[SUGGESTION_KEYS.id] === description.suggestionId &&\n          !!node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n    removeNodes(editor as any, {\n      at: [],\n      match: (n) => {\n        const node = n as TSuggestionText;\n\n        // remove additions\n        return (\n          node[SUGGESTION_KEYS.id] === description.suggestionId &&\n          !node.suggestionDeletion &&\n          !!node[suggestionKey]\n        );\n      },\n    });\n  });\n};\n"],"mappings":"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","names":["nanoid","getPointAfter","getPointBefore","removeNodes","setNodes","getEdgePoints","withoutNormalizing","findNode","getPointAfter","getPointBefore","nanoid","withoutNormalizing","getNodeEntries","getNodeEntries","withoutNormalizing","nanoid","getPointBefore","getPointAfter","findNode","withoutNormalizing","getEdgePoints","nanoid","withoutNormalizing","withoutNormalizing","nanoid","nanoid","withoutNormalizing","withoutNormalizing","nanoid","getPointBefore","getPointAfter","setNodes","removeNodes","nanoid","nanoid","removeNodes","unsetNodes","withoutNormalizing","withoutNormalizing","unsetNodes","removeNodes","nanoid","nanoid","removeNodes","unsetNodes","withoutNormalizing","withoutNormalizing","unsetNodes","removeNodes","nanoid","isInline"]}